generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =========================
// Core identity & access (RBAC)
// =========================

enum UserStatus {
  ACTIVE
  BLOCKED
  DELETED
}

enum UserRoleEnum {
  USER
  MODERATOR   // чат поддержки, помощь в редактировании объявлений
  MANAGER     // approve/reject объявлений
  ADMIN       // роли, модерация, пуш, аналитика
  ROOT        // legba086@mail.ru, нельзя понизить (проверка по email в коде)
}

enum UserPlan {
  FREE
  PRO
  AGENCY
}

model User {
  id           String      @id @default(uuid())
  email        String?     @unique
  phone        String?     @unique
  passwordHash String?
  status       UserStatus  @default(ACTIVE)
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  /// ID пользователя в Supabase Auth
  supabaseId   String?     @unique
  /// Strict supabase uid mirror (UUID) for audits & joins
  supabaseUuid String?     @unique @db.Uuid @map("supabase_id")
  /// Упрощённая прикладная роль (для быстрого доступа)
  appRole      UserRoleEnum @default(USER)

  /// Tariff plan for business logic (listing limits, analytics gates, etc.)
  plan         UserPlan     @default(FREE)
  /// Denormalized limit for faster checks (keep in sync with plan)
  listingLimit Int          @default(1)

  profile      Profile?
  roles        UserRole[]
  refreshTokens RefreshToken[]

  listings      Listing[]    @relation("ListingOwner")
  listingsModerated Listing[] @relation("ListingModerator")
  bookingsAsGuest Booking[]  @relation("BookingGuest")
  bookingsAsHost  Booking[]  @relation("BookingHost")

  aiProfile    AiProfile?
  aiEvents     AiEvent[]
  aiEmbeddings AiEmbedding[] @relation("UserEmbeddings")
  auditLogs    AuditLog[]  @relation("AuditActor")

  reviewsAuthored Review[] @relation("ReviewAuthor")
  reputation      UserReputation?
  favorites       Favorite[]
  notifications     Notification[]
  pushSubscriptions PushSubscription[]

  conversationsAsHost  Conversation[] @relation("ConversationHost")
  conversationsAsGuest Conversation[] @relation("ConversationGuest")
  messagesSent         Message[]
  payments             Payment[]
}

model Profile {
  userId              String    @id
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  name                String?
  username            String?
  avatarUrl           String?
  email               String?
  phone               String?
  locale              String    @default("ru")
  /// AI onboarding params (budget, rooms, district, duration, propertyType)
  aiParams            Json?
  nameChangedAt       DateTime?
  nameChangeCountDay  Int       @default(0)
  nameChangeCountMonth Int      @default(0)
  lastDayResetAt      DateTime?
  lastMonthResetAt    DateTime?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
}

/// Репутация пользователя (ТЗ-7): рейтинг как хозяина и как гостя, доверие
model UserReputation {
  userId     String   @id
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  hostScore  Float?   // средний рейтинг по отзывам на объявлениях владельца (1–5 или 0–100)
  guestScore Float?   // рейтинг как арендатор (пока от хозяев — в будущем)
  trustScore Float?   // агрегат доверия (0–100), опционально

  updatedAt  DateTime @updatedAt
  createdAt  DateTime @default(now())

  @@index([userId])
}

model Role {
  id          String           @id @default(uuid())
  name        String           @unique
  description String?
  createdAt   DateTime         @default(now())
  users       UserRole[]
  permissions RolePermission[]
}

model Permission {
  id          String           @id @default(uuid())
  key         String           @unique
  description String?
  createdAt   DateTime         @default(now())
  roles       RolePermission[]
}

model UserRole {
  userId String
  roleId String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@id([userId, roleId])
}

model RolePermission {
  roleId       String
  permissionId String

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
}

// =========================
// Auth: Telegram Login with Phone + Policy
// =========================

enum TelegramAuthStatus {
  PENDING
  PHONE_RECEIVED
  CONFIRMED
  EXPIRED
}

model TelegramAuthSession {
  id              String            @id @default(uuid())
  loginToken      String            @unique
  telegramUserId  BigInt?
  phoneNumber     String?
  username        String?
  firstName       String?
  policyAccepted  Boolean           @default(false)
  status          TelegramAuthStatus @default(PENDING)
  createdAt       DateTime          @default(now())

  loginTokens     TelegramLoginToken[]

  @@index([telegramUserId])
  @@index([phoneNumber])
  @@index([status])
  @@index([createdAt])
  @@index([status, createdAt])
}

model TelegramLoginToken {
  id            String             @id @default(uuid())
  token         String             @unique
  sessionId     String
  session       TelegramAuthSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  userId        String?
  accessToken   String?
  refreshToken  String?
  expiresAt     DateTime
  used          Boolean            @default(false)
  usedAt        DateTime?
  createdAt     DateTime           @default(now())

  @@index([sessionId])
  @@index([expiresAt])
  @@index([userId])
  @@index([used])
  @@index([userId, expiresAt])
  @@index([used, expiresAt])
}

// =========================
// Auth: Refresh Tokens
// =========================

model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  revokedAt DateTime?

  /// Device/session identifier (for multi-device sessions)
  device    String?
  userAgent String?
  ip        String?

  @@index([userId])
  @@index([userId, device])
  @@index([token])
  @@index([expiresAt])
}

// =========================
// Core marketplace (MVP stage 2)
// =========================

enum ListingStatus {
  DRAFT              // Черновик (создано, можно редактировать)
  AWAITING_PAYMENT   // Ожидает оплаты
  PENDING_REVIEW     // На модерации (после оплаты)
  PUBLISHED          // Опубликовано (одобрено админом)
  REJECTED           // Отклонено админом
  BLOCKED            // Заблокировано
  ARCHIVED           // В архиве
}

enum ListingType {
  APARTMENT
  HOUSE
  ROOM
  STUDIO
}

model Listing {
  id           String         @id @default(uuid())
  ownerId      String
  owner        User           @relation("ListingOwner", fields: [ownerId], references: [id], onDelete: Restrict)

  title        String
  description  String
  type         ListingType    @default(APARTMENT)

  city         String
  addressLine  String?
  lat          Float?
  lng          Float?

  // Pricing (nightly). For monthly rentals we can derive via long-stay rules later.
  basePrice    Int
  currency     String         @default("RUB")

  capacityGuests Int          @default(2)
  bedrooms       Int          @default(1)
  beds           Int          @default(1)
  bathrooms      Float        @default(1)

  houseRules   Json?

  status       ListingStatus  @default(DRAFT)
  /// Причина отклонения (legacy field, kept for backward compatibility)
  moderationComment String?
  /// TZ-36: canonical moderation note (shown in owner UI)
  moderationNote    String?       @map("moderation_note")
  /// TZ-36: publication timestamp
  publishedAt       DateTime?     @map("published_at")
  /// TZ-36: rejection timestamp
  rejectedAt        DateTime?     @map("rejected_at")
  /// Кто одобрил/отклонил (User id)
  moderatedById     String?
  moderatedBy        User?     @relation("ListingModerator", fields: [moderatedById], references: [id], onDelete: SetNull)
  viewsCount   Int            @default(0)
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt

  photos       ListingPhoto[]
  amenities    ListingAmenity[]
  availability AvailabilityDay[]
  priceRules   PriceRule[]

  bookings     Booking[]
  reviews      Review[]
  metricAggs   ListingMetricAgg[]

  aiScores     AiListingScore?
  aiEmbeddings AiEmbedding[] @relation("ListingEmbeddings")
  aiEvents     AiEvent[]
  
  // Product Intelligence
  intelligence PropertyIntelligence?
  
  // Favorites
  favoritedBy  Favorite[]
  
  // AI Assistant Analysis
  analysis     ListingAnalysis?

  // Views
  views        ListingView[]
  // TZ-38 analytics counters
  listingStats ListingStats?

  conversations Conversation[]

  /// ТЗ-8: кэш рейтинга и метрик для AI { rating, cleanliness, noise, reviews, ... }
  ratingCache  Json?

  @@index([ownerId])
  @@index([status])
  @@index([createdAt])
  @@index([city])
  @@index([status, createdAt])
  @@index([city, status, createdAt])
  @@index([ownerId, status, createdAt])
  @@index([status, basePrice])
  @@index([status, capacityGuests])
  @@index([status, type])
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELED
}

model Booking {
  id         String        @id @default(uuid())
  listingId  String
  guestId    String
  hostId     String

  listing    Listing       @relation(fields: [listingId], references: [id], onDelete: Restrict)
  guest      User          @relation("BookingGuest", fields: [guestId], references: [id], onDelete: Restrict)
  host       User          @relation("BookingHost", fields: [hostId], references: [id], onDelete: Restrict)

  checkIn    DateTime
  checkOut   DateTime
  guestsCount Int          @default(1)
  totalPrice Int
  currency   String        @default("RUB")
  status     BookingStatus @default(PENDING)

  priceBreakdown Json?

  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt

  review     Review?

  @@index([listingId, checkIn, checkOut])
  @@index([hostId, createdAt])
  @@index([guestId])
  @@index([status])
  @@index([createdAt])
  @@index([guestId, createdAt])
  @@index([status, createdAt])
  @@index([hostId, status])
}

// Payments (test mode). Юнит-экономика: доход, GMV.
model Payment {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Restrict)
  amount    Int      // копейки или целые рубли
  currency  String   @default("RUB")
  status    String   // PENDING | SUCCEEDED | FAILED | REFUNDED
  type      String   // BOOKING | SUBSCRIPTION | ...
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

// =========================
// Chat 1-1 (LOCUS Core V1)
// =========================
model Conversation {
  id         String   @id @default(uuid())
  listingId  String
  listing    Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  hostId     String   // владелец объявления
  host       User     @relation("ConversationHost", fields: [hostId], references: [id], onDelete: Cascade)
  guestId    String   // покупатель / кто написал
  guest      User     @relation("ConversationGuest", fields: [guestId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  messages   Message[]

  @@unique([listingId, guestId])
  @@index([hostId])
  @@index([guestId])
  @@index([updatedAt])
}

model Message {
  id             String   @id @default(uuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  senderId       String
  sender         User     @relation(fields: [senderId], references: [id], onDelete: Cascade)
  text           String
  readAt         DateTime?
  createdAt      DateTime @default(now())

  @@index([conversationId])
  @@index([senderId])
  @@index([createdAt])
}

model ListingPhoto {
  id        String   @id @default(uuid())
  listingId String
  listing   Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  url       String
  sortOrder Int      @default(0)
  createdAt DateTime @default(now())

  @@index([listingId, sortOrder])
}

model ListingView {
  id           String   @id @default(uuid())
  listingId    String
  listing      Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  sessionId    String
  userId       String?
  lastViewedAt DateTime @default(now())
  createdAt    DateTime @default(now())

  @@unique([listingId, sessionId])
  @@index([listingId])
  @@index([sessionId])
}

/// TZ-38: aggregated listing analytics counters
model ListingStats {
  listingId  String   @id @map("listing_id")
  listing    Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  views      Int      @default(0)
  favorites  Int      @default(0)
  messages   Int      @default(0)
  bookings   Int      @default(0)
  updatedAt  DateTime @updatedAt @map("updated_at")

  @@index([updatedAt])
  @@map("listing_stats")
}

model Amenity {
  id        String   @id @default(uuid())
  key       String   @unique
  label     String
  createdAt DateTime @default(now())

  listings ListingAmenity[]
}

model ListingAmenity {
  listingId String
  amenityId String

  listing Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  amenity Amenity @relation(fields: [amenityId], references: [id], onDelete: Cascade)

  @@id([listingId, amenityId])
  @@index([amenityId])
}

model AvailabilityDay {
  id         String   @id @default(uuid())
  listingId  String
  listing    Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)

  // store as DateTime at 00:00 UTC (convention)
  date       DateTime
  isAvailable Boolean @default(true)
  priceOverride Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([listingId, date])
  @@index([date])
}

enum PriceRuleType {
  WEEKEND
  LONG_STAY_DISCOUNT
  LAST_MINUTE
}

model PriceRule {
  id        String       @id @default(uuid())
  listingId String
  listing   Listing      @relation(fields: [listingId], references: [id], onDelete: Cascade)
  type      PriceRuleType

  // Either percent OR absolute delta (MVP: keep it simple)
  deltaPct  Int?
  deltaAbs  Int?

  activeFrom DateTime?
  activeTo   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([listingId, type])
}

model Review {
  id        String   @id @default(uuid())
  listingId String
  bookingId String?  @unique
  authorId  String

  listing   Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  booking   Booking? @relation(fields: [bookingId], references: [id], onDelete: SetNull)
  author    User     @relation("ReviewAuthor", fields: [authorId], references: [id], onDelete: Restrict)

  rating    Int
  text      String?

  /// ТЗ-6: структурированные метрики в JSON для аналитики/AI
  metricsJson Json?
  /// ТЗ-7: вес отзыва для взвешенного рейтинга (0.3–1.2)
  aiWeight   Float   @default(1)
  /// ТЗ-6: тип визита (night, long, short)
  visitType  String?
  /// ТЗ-6: количество дней проживания
  stayDays   Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  metrics          ReviewMetric[]
  structuredMetrics ReviewMetrics?
  tags             ReviewTag[]

  @@unique([listingId, authorId])
  @@index([listingId, createdAt])
  @@index([authorId])
  @@index([authorId, createdAt])
}

model ReviewMetric {
  id        String   @id @default(uuid())
  reviewId  String
  review    Review   @relation(fields: [reviewId], references: [id], onDelete: Cascade)

  metricKey String
  value     Int

  createdAt DateTime @default(now())

  @@unique([reviewId, metricKey])
  @@index([reviewId])
  @@index([metricKey])
}

/// Структурированные метрики отзыва для AI (шум, чистота, хозяева, район, ценность, заселение)
model ReviewMetrics {
  id        String   @id @default(uuid())
  reviewId  String   @unique
  review    Review   @relation(fields: [reviewId], references: [id], onDelete: Cascade)

  cleanliness Int?   // 0..100
  location    Int?   // 0..100 район
  noise       Int?   // 0..100 шум
  owner       Int?   // 0..100 хозяева / коммуникация
  value       Int?   // 0..100 цена/качество
  checkin    Int?   // 0..100 заселение
  safety      Int?   // 0..100 безопасность (под AI)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([reviewId])
}

/// Теги отзыва (для AI и фильтров)
model ReviewTag {
  id      String  @id @default(uuid())
  reviewId String
  review   Review  @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  tag      String

  @@unique([reviewId, tag])
  @@index([reviewId])
  @@index([tag])
}

/// ТЗ-9: вопросы для формы отзыва (случайный выбор 5 из активных)
model ReviewQuestion {
  id     String  @id @default(uuid())
  key    String  @unique
  label  String
  active Boolean @default(true)
  createdAt DateTime @default(now())

  @@index([active])
}

model ListingMetricAgg {
  listingId String
  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)

  metricKey String
  avgValue  Float   @default(0)
  count     Int     @default(0)
  updatedAt DateTime @updatedAt

  @@id([listingId, metricKey])
  @@index([listingId])
  @@index([metricKey])
}

// =========================
// AI-ready data model
// =========================

enum AiEntityType {
  USER
  LISTING
  BOOKING
  MESSAGE
  SEARCH_QUERY
}

enum AiEventType {
  AI_SEARCH
  AI_RECOMMENDATIONS
  AI_PRICING
  AI_RISK
  AI_QUALITY
  AI_ASSISTANT
}

enum AiExplanationType {
  SEARCH_EXPLANATION
  PRICING_EXPLANATION
  QUALITY_EXPLANATION
  RISK_EXPLANATION
  ASSISTANT_EXPLANATION
}

model AiProfile {
  userId     String  @id
  user       User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  // AI-personalization: preferences, constraints, do-not-show, etc.
  preferences Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model AiExplanation {
  id        String            @id @default(uuid())
  type      AiExplanationType
  text      String
  bullets   String[]          @default([])
  meta      Json?
  createdAt DateTime          @default(now())

  listingScores AiListingScore[]
}

model AiListingScore {
  listingId   String @id
  listing     Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)

  qualityScore Int? // 0..100
  riskScore    Int? // 0..100
  demandScore  Int? // 0..100
  priceScore   Int? // 0..100

  explanationId String?
  explanation   AiExplanation? @relation(fields: [explanationId], references: [id], onDelete: SetNull)

  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())
}

// =========================
// Product Intelligence (AI Core)
// =========================

model PropertyIntelligence {
  id              String   @id @default(uuid())
  listingId       String   @unique
  listing         Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)

  // Core scores (0-100)
  qualityScore         Int      @default(0)
  demandScore          Int      @default(0)
  riskScore            Int      @default(0)
  completenessScore    Int      @default(0)

  // Predictions
  bookingProbability   Float    @default(0) // 0.0-1.0
  recommendedPrice     Int?
  priceDeltaPercent    Float?   // % difference from current price
  revenueForecast30d   Int?     // Expected revenue next 30 days

  // Market analysis
  marketPosition       String?  // "below_market" | "at_market" | "above_market"
  competitorCount      Int      @default(0)
  avgMarketPrice       Int?

  // Risk factors
  riskFactors          Json?    // Array of risk flags
  riskLevel            String   @default("low") // "low" | "medium" | "high"

  // Explanation (human-readable)
  explanation          Json?    // { text, bullets, suggestions }

  // Metadata
  lastCalculatedAt     DateTime @default(now())
  calculationVersion   String   @default("v1")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([qualityScore])
  @@index([demandScore])
  @@index([riskLevel])
}

model AiEmbedding {
  id         String       @id @default(uuid())
  entityType AiEntityType
  entityId   String
  model      String

  // MVP: store as Float[] for portability.
  // Later: move to pgvector for similarity search + ANN index.
  vector     Float[]
  meta       Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Typed optional relations for cases where we want strong FK constraints.
  // Keep `entityType/entityId` as the source of truth for generic embeddings.
  listingId String?
  listing   Listing? @relation("ListingEmbeddings", fields: [listingId], references: [id], onDelete: Cascade)

  userId     String?
  user       User?     @relation("UserEmbeddings", fields: [userId], references: [id], onDelete: Cascade)

  @@index([entityType, entityId])
  @@index([model])
  @@index([listingId])
  @@index([userId])
}

model AiEvent {
  id        String      @id @default(uuid())
  type      AiEventType
  userId    String?
  listingId String?
  payload   Json?
  createdAt DateTime    @default(now())

  user      User?       @relation(fields: [userId], references: [id], onDelete: SetNull)
  listing   Listing?    @relation(fields: [listingId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([listingId])
  @@index([type])
  @@index([createdAt])
  @@index([userId, createdAt])
  @@index([listingId, createdAt])
  @@index([type, createdAt])
}

// =========================
// Audit (admin-ready)
// =========================

model AuditLog {
  id         String   @id @default(uuid())
  actorId    String?
  actor      User?    @relation("AuditActor", fields: [actorId], references: [id], onDelete: SetNull)
  action     String
  entityType String
  entityId   String
  before     Json?
  after      Json?
  ip         String?
  createdAt  DateTime @default(now())

  @@index([entityType, entityId])
  @@index([createdAt])
}

// =========================
// Favorites (like Avito)
// =========================

model Favorite {
  id        String   @id @default(uuid())
  userId    String
  listingId String
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  listing   Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())

  @@unique([userId, listingId])
  @@index([userId])
  @@index([listingId])
  @@index([userId, createdAt])
}

// =========================
// Notifications
// =========================
model Notification {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      String   // NEW_LISTING_PENDING, ..., BOOKING_CONFIRMED, REVIEW_REMINDER
  title     String
  text      String?
  body      String?
  link      String?
  entityId  String?
  meta      Json?    // для REVIEW_REMINDER: { listingId }
  isRead    Boolean  @default(false)
  isSeen    Boolean  @default(false)
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([userId, read])
  @@index([userId, isRead])
  @@index([userId, isSeen])
  @@index([userId, type, entityId, createdAt])
  @@index([userId, createdAt])
}

model PushSubscription {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  endpoint  String
  p256dh    String
  auth      String
  createdAt DateTime @default(now())

  @@unique([userId, endpoint])
  @@index([userId])
}

// =========================
// Listing Insight (AI Product Layer)
// =========================
model ListingInsight {
  id        String   @id @default(uuid())
  listingId String   @unique
  
  // Core score (0-100)
  score     Int      @default(0)
  
  // Verdict
  verdict   String   @default("average") // "excellent" | "good" | "average" | "bad"
  
  // Price analysis
  priceDiff Float    @default(0) // % diff from market
  
  // Human-readable
  pros      Json?    // string[]
  cons      Json?    // string[]
  risks     Json?    // string[]
  
  // Demand
  demand    String   @default("medium") // "low" | "medium" | "high"
  
  // Booking probability
  bookingProbability Float @default(0.5)
  
  // Recommended price
  recommendedPrice Float?
  
  // Tips
  tips      Json?    // string[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([score])
  @@index([verdict])
}

// =========================
// Listing Analysis (Legacy AI Assistant)
// =========================

model ListingAnalysis {
  id          String   @id @default(uuid())
  listingId   String   @unique
  listing     Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  
  // LOCUS Rating (0-100)
  locusRating     Int      @default(0)
  ratingLabel     String   @default("average") // "excellent" | "good" | "average" | "needs_improvement"
  
  // Price Analysis
  priceAdvice     Float?   // Recommended price
  pricePosition   String?  // "below_market" | "market" | "above_market"
  priceDiffPercent Float?  // % difference from recommended
  
  // Risk Assessment
  riskLevel       String   @default("low") // "low" | "medium" | "high"
  riskFactors     Json?    // Array of risk factors
  
  // Market Analysis  
  marketDemand    String?  // "high" | "medium" | "low"
  competitorCount Int?
  avgMarketPrice  Float?
  
  // Explanation (human-readable)
  explanation     Json?    // { summary, pros, cons, tips }
  
  // Improvement suggestions
  improvements    Json?    // Array of { type, description, impact }
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([locusRating])
  @@index([riskLevel])
}