generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =========================
// Core identity & access (RBAC)
// =========================

enum UserStatus {
  ACTIVE
  BLOCKED
  DELETED
}

enum UserRoleEnum {
  USER
  ADMIN
}

model User {
  id           String      @id @default(uuid())
  email        String?     @unique
  phone        String?     @unique
  passwordHash String?
  status       UserStatus  @default(ACTIVE)
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  /// ID пользователя в Supabase Auth
  supabaseId   String?     @unique
  /// Упрощённая прикладная роль (для быстрого доступа)
  appRole      UserRoleEnum @default(USER)

  profile      Profile?
  roles        UserRole[]
  refreshTokens RefreshToken[]

  listings      Listing[]    @relation("ListingOwner")
  bookingsAsGuest Booking[]  @relation("BookingGuest")
  bookingsAsHost  Booking[]  @relation("BookingHost")

  aiProfile    AiProfile?
  aiEvents     AiEvent[]
  aiEmbeddings AiEmbedding[] @relation("UserEmbeddings")
  auditLogs    AuditLog[]  @relation("AuditActor")

  reviewsAuthored Review[] @relation("ReviewAuthor")
  favorites       Favorite[]
}

model Profile {
  userId    String   @id
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  name      String?
  avatarUrl String?
  locale    String   @default("ru")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Role {
  id          String           @id @default(uuid())
  name        String           @unique
  description String?
  createdAt   DateTime         @default(now())
  users       UserRole[]
  permissions RolePermission[]
}

model Permission {
  id          String           @id @default(uuid())
  key         String           @unique
  description String?
  createdAt   DateTime         @default(now())
  roles       RolePermission[]
}

model UserRole {
  userId String
  roleId String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@id([userId, roleId])
}

model RolePermission {
  roleId       String
  permissionId String

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
}

// =========================
// Auth: Refresh Tokens
// =========================

model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  revokedAt DateTime?

  userAgent String?
  ip        String?

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

// =========================
// Core marketplace (MVP stage 2)
// =========================

enum ListingStatus {
  DRAFT              // Черновик (создано, можно редактировать)
  AWAITING_PAYMENT   // Ожидает оплаты
  PENDING_REVIEW     // На модерации (после оплаты)
  PUBLISHED          // Опубликовано (одобрено админом)
  REJECTED           // Отклонено админом
  BLOCKED            // Заблокировано
  ARCHIVED           // В архиве
}

enum ListingType {
  APARTMENT
  HOUSE
  ROOM
  STUDIO
}

model Listing {
  id           String         @id @default(uuid())
  ownerId      String
  owner        User           @relation("ListingOwner", fields: [ownerId], references: [id], onDelete: Restrict)

  title        String
  description  String
  type         ListingType    @default(APARTMENT)

  city         String
  addressLine  String?
  lat          Float?
  lng          Float?

  // Pricing (nightly). For monthly rentals we can derive via long-stay rules later.
  basePrice    Int
  currency     String         @default("RUB")

  capacityGuests Int          @default(2)
  bedrooms       Int          @default(1)
  beds           Int          @default(1)
  bathrooms      Float        @default(1)

  houseRules   Json?

  status       ListingStatus  @default(DRAFT)
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt

  photos       ListingPhoto[]
  amenities    ListingAmenity[]
  availability AvailabilityDay[]
  priceRules   PriceRule[]

  bookings     Booking[]
  reviews      Review[]

  aiScores     AiListingScore?
  aiEmbeddings AiEmbedding[] @relation("ListingEmbeddings")
  aiEvents     AiEvent[]
  
  // Product Intelligence
  intelligence PropertyIntelligence?
  
  // Favorites
  favoritedBy  Favorite[]
  
  // AI Assistant Analysis
  analysis     ListingAnalysis?
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELED
}

model Booking {
  id         String        @id @default(uuid())
  listingId  String
  guestId    String
  hostId     String

  listing    Listing       @relation(fields: [listingId], references: [id], onDelete: Restrict)
  guest      User          @relation("BookingGuest", fields: [guestId], references: [id], onDelete: Restrict)
  host       User          @relation("BookingHost", fields: [hostId], references: [id], onDelete: Restrict)

  checkIn    DateTime
  checkOut   DateTime
  guestsCount Int          @default(1)
  totalPrice Int
  currency   String        @default("RUB")
  status     BookingStatus @default(PENDING)

  priceBreakdown Json?

  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt

  review     Review?

  @@index([listingId, checkIn, checkOut])
  @@index([hostId, createdAt])
}

model ListingPhoto {
  id        String   @id @default(uuid())
  listingId String
  listing   Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  url       String
  sortOrder Int      @default(0)
  createdAt DateTime @default(now())

  @@index([listingId, sortOrder])
}

model Amenity {
  id        String   @id @default(uuid())
  key       String   @unique
  label     String
  createdAt DateTime @default(now())

  listings ListingAmenity[]
}

model ListingAmenity {
  listingId String
  amenityId String

  listing Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  amenity Amenity @relation(fields: [amenityId], references: [id], onDelete: Cascade)

  @@id([listingId, amenityId])
  @@index([amenityId])
}

model AvailabilityDay {
  id         String   @id @default(uuid())
  listingId  String
  listing    Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)

  // store as DateTime at 00:00 UTC (convention)
  date       DateTime
  isAvailable Boolean @default(true)
  priceOverride Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([listingId, date])
  @@index([date])
}

enum PriceRuleType {
  WEEKEND
  LONG_STAY_DISCOUNT
  LAST_MINUTE
}

model PriceRule {
  id        String       @id @default(uuid())
  listingId String
  listing   Listing      @relation(fields: [listingId], references: [id], onDelete: Cascade)
  type      PriceRuleType

  // Either percent OR absolute delta (MVP: keep it simple)
  deltaPct  Int?
  deltaAbs  Int?

  activeFrom DateTime?
  activeTo   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([listingId, type])
}

model Review {
  id        String   @id @default(uuid())
  listingId String
  bookingId String?  @unique
  authorId  String

  listing   Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  booking   Booking? @relation(fields: [bookingId], references: [id], onDelete: SetNull)
  author    User     @relation("ReviewAuthor", fields: [authorId], references: [id], onDelete: Restrict)

  rating    Int
  text      String?

  createdAt DateTime @default(now())

  @@index([listingId, createdAt])
}

// =========================
// AI-ready data model
// =========================

enum AiEntityType {
  USER
  LISTING
  BOOKING
  MESSAGE
  SEARCH_QUERY
}

enum AiEventType {
  AI_SEARCH
  AI_RECOMMENDATIONS
  AI_PRICING
  AI_RISK
  AI_QUALITY
  AI_ASSISTANT
}

enum AiExplanationType {
  SEARCH_EXPLANATION
  PRICING_EXPLANATION
  QUALITY_EXPLANATION
  RISK_EXPLANATION
  ASSISTANT_EXPLANATION
}

model AiProfile {
  userId     String  @id
  user       User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  // AI-personalization: preferences, constraints, do-not-show, etc.
  preferences Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model AiExplanation {
  id        String            @id @default(uuid())
  type      AiExplanationType
  text      String
  bullets   String[]          @default([])
  meta      Json?
  createdAt DateTime          @default(now())

  listingScores AiListingScore[]
}

model AiListingScore {
  listingId   String @id
  listing     Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)

  qualityScore Int? // 0..100
  riskScore    Int? // 0..100
  demandScore  Int? // 0..100
  priceScore   Int? // 0..100

  explanationId String?
  explanation   AiExplanation? @relation(fields: [explanationId], references: [id], onDelete: SetNull)

  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())
}

// =========================
// Product Intelligence (AI Core)
// =========================

model PropertyIntelligence {
  id              String   @id @default(uuid())
  listingId       String   @unique
  listing         Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)

  // Core scores (0-100)
  qualityScore         Int      @default(0)
  demandScore          Int      @default(0)
  riskScore            Int      @default(0)
  completenessScore    Int      @default(0)

  // Predictions
  bookingProbability   Float    @default(0) // 0.0-1.0
  recommendedPrice     Int?
  priceDeltaPercent    Float?   // % difference from current price
  revenueForecast30d   Int?     // Expected revenue next 30 days

  // Market analysis
  marketPosition       String?  // "below_market" | "at_market" | "above_market"
  competitorCount      Int      @default(0)
  avgMarketPrice       Int?

  // Risk factors
  riskFactors          Json?    // Array of risk flags
  riskLevel            String   @default("low") // "low" | "medium" | "high"

  // Explanation (human-readable)
  explanation          Json?    // { text, bullets, suggestions }

  // Metadata
  lastCalculatedAt     DateTime @default(now())
  calculationVersion   String   @default("v1")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([qualityScore])
  @@index([demandScore])
  @@index([riskLevel])
}

model AiEmbedding {
  id         String       @id @default(uuid())
  entityType AiEntityType
  entityId   String
  model      String

  // MVP: store as Float[] for portability.
  // Later: move to pgvector for similarity search + ANN index.
  vector     Float[]
  meta       Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Typed optional relations for cases where we want strong FK constraints.
  // Keep `entityType/entityId` as the source of truth for generic embeddings.
  listingId String?
  listing   Listing? @relation("ListingEmbeddings", fields: [listingId], references: [id], onDelete: Cascade)

  userId     String?
  user       User?     @relation("UserEmbeddings", fields: [userId], references: [id], onDelete: Cascade)

  @@index([entityType, entityId])
  @@index([model])
  @@index([listingId])
  @@index([userId])
}

model AiEvent {
  id        String      @id @default(uuid())
  type      AiEventType
  userId    String?
  listingId String?
  payload   Json?
  createdAt DateTime    @default(now())

  user      User?       @relation(fields: [userId], references: [id], onDelete: SetNull)
  listing   Listing?    @relation(fields: [listingId], references: [id], onDelete: SetNull)
}

// =========================
// Audit (admin-ready)
// =========================

model AuditLog {
  id         String   @id @default(uuid())
  actorId    String?
  actor      User?    @relation("AuditActor", fields: [actorId], references: [id], onDelete: SetNull)
  action     String
  entityType String
  entityId   String
  before     Json?
  after      Json?
  ip         String?
  createdAt  DateTime @default(now())

  @@index([entityType, entityId])
  @@index([createdAt])
}

// =========================
// Favorites (like Avito)
// =========================

model Favorite {
  id        String   @id @default(uuid())
  userId    String
  listingId String
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  listing   Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())

  @@unique([userId, listingId])
  @@index([userId])
  @@index([listingId])
}

// =========================
// Listing Insight (AI Product Layer)
// =========================
model ListingInsight {
  id        String   @id @default(uuid())
  listingId String   @unique
  
  // Core score (0-100)
  score     Int      @default(0)
  
  // Verdict
  verdict   String   @default("average") // "excellent" | "good" | "average" | "bad"
  
  // Price analysis
  priceDiff Float    @default(0) // % diff from market
  
  // Human-readable
  pros      Json?    // string[]
  cons      Json?    // string[]
  risks     Json?    // string[]
  
  // Demand
  demand    String   @default("medium") // "low" | "medium" | "high"
  
  // Booking probability
  bookingProbability Float @default(0.5)
  
  // Recommended price
  recommendedPrice Float?
  
  // Tips
  tips      Json?    // string[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([score])
  @@index([verdict])
}

// =========================
// Listing Analysis (Legacy AI Assistant)
// =========================

model ListingAnalysis {
  id          String   @id @default(uuid())
  listingId   String   @unique
  listing     Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  
  // LOCUS Rating (0-100)
  locusRating     Int      @default(0)
  ratingLabel     String   @default("average") // "excellent" | "good" | "average" | "needs_improvement"
  
  // Price Analysis
  priceAdvice     Float?   // Recommended price
  pricePosition   String?  // "below_market" | "market" | "above_market"
  priceDiffPercent Float?  // % difference from recommended
  
  // Risk Assessment
  riskLevel       String   @default("low") // "low" | "medium" | "high"
  riskFactors     Json?    // Array of risk factors
  
  // Market Analysis  
  marketDemand    String?  // "high" | "medium" | "low"
  competitorCount Int?
  avgMarketPrice  Float?
  
  // Explanation (human-readable)
  explanation     Json?    // { summary, pros, cons, tips }
  
  // Improvement suggestions
  improvements    Json?    // Array of { type, description, impact }
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([locusRating])
  @@index([riskLevel])
}