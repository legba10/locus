generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =========================
// Core identity & access
// =========================

enum UserStatus {
  ACTIVE
  BLOCKED
  DELETED
}

model User {
  id           String     @id @default(uuid())
  email        String?    @unique
  phone        String?    @unique
  passwordHash String?
  status       UserStatus @default(ACTIVE)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  profile Profile?
  roles   UserRole[]

  ownedProperties Property[] @relation("PropertyOwner")
  bookings        Booking[]  @relation("BookingGuest")

  aiProfile    AiProfile?
  aiEvents     AiEvent[]
  aiEmbeddings AiEmbedding[] @relation("UserEmbeddings")
  auditLogs    AuditLog[]    @relation("AuditActor")
}

model Profile {
  userId    String   @id
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  name      String?
  avatarUrl String?
  locale    String   @default("ru")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Role {
  id          String           @id @default(uuid())
  name        String           @unique
  description String?
  createdAt   DateTime         @default(now())
  users       UserRole[]
  permissions RolePermission[]
}

model Permission {
  id          String           @id @default(uuid())
  key         String           @unique
  description String?
  createdAt   DateTime         @default(now())
  roles       RolePermission[]
}

model UserRole {
  userId String
  roleId String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@id([userId, roleId])
}

model RolePermission {
  roleId       String
  permissionId String

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
}

// =========================
// Core marketplace (MVP)
// =========================

enum PropertyStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

model Property {
  id      String @id @default(uuid())
  ownerId String
  owner   User   @relation("PropertyOwner", fields: [ownerId], references: [id], onDelete: Restrict)

  title       String
  description String

  city        String
  addressLine String?
  lat         Float?
  lng         Float?

  // MVP: monthly rental simplified; later split nightly/monthly pricing
  monthlyPrice Int
  currency     String @default("RUB")

  // Optional signal for "тихо" matching; can be computed by AI later
  noiseScore Int? // 0..100 (higher = quieter)

  status    PropertyStatus @default(DRAFT)
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt

  bookings     Booking[]
  aiScores     AiPropertyScore?
  aiEmbeddings AiEmbedding[]    @relation("PropertyEmbeddings")
  aiEvents     AiEvent[]
}

enum BookingStatus {
  CREATED
  CONFIRMED
  CANCELLED
  COMPLETED
}

model Booking {
  id         String @id @default(uuid())
  propertyId String
  guestId    String

  property Property @relation(fields: [propertyId], references: [id], onDelete: Restrict)
  guest    User     @relation("BookingGuest", fields: [guestId], references: [id], onDelete: Restrict)

  checkIn    DateTime
  checkOut   DateTime
  totalPrice Int
  currency   String        @default("RUB")
  status     BookingStatus @default(CREATED)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// =========================
// AI-ready data model
// =========================

enum AiEntityType {
  USER
  PROPERTY
  BOOKING
  MESSAGE
  SEARCH_QUERY
}

enum AiEventType {
  AI_SEARCH
  AI_RECOMMENDATIONS
  AI_PRICING
  AI_RISK
  AI_QUALITY
  AI_ASSISTANT
}

enum AiExplanationType {
  SEARCH_EXPLANATION
  PRICING_EXPLANATION
  QUALITY_EXPLANATION
  RISK_EXPLANATION
  ASSISTANT_EXPLANATION
}

model AiProfile {
  userId String @id
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // AI-personalization: preferences, constraints, do-not-show, etc.
  preferences Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model AiExplanation {
  id        String            @id @default(uuid())
  type      AiExplanationType
  text      String
  bullets   String[]          @default([])
  meta      Json?
  createdAt DateTime          @default(now())

  propertyScores AiPropertyScore[]
}

model AiPropertyScore {
  propertyId String   @id
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  qualityScore Int? // 0..100
  riskScore    Int? // 0..100
  demandScore  Int? // 0..100
  priceScore   Int? // 0..100

  explanationId String?
  explanation   AiExplanation? @relation(fields: [explanationId], references: [id], onDelete: SetNull)

  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())
}

model AiEmbedding {
  id         String       @id @default(uuid())
  entityType AiEntityType
  entityId   String
  model      String

  // MVP: store as Float[] for portability.
  // Later: move to pgvector for similarity search + ANN index.
  vector Float[]
  meta   Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Typed optional relations for cases where we want strong FK constraints.
  // Keep `entityType/entityId` as the source of truth for generic embeddings.
  propertyId String?
  property   Property? @relation("PropertyEmbeddings", fields: [propertyId], references: [id], onDelete: Cascade)

  userId String?
  user   User?   @relation("UserEmbeddings", fields: [userId], references: [id], onDelete: Cascade)

  @@index([entityType, entityId])
  @@index([model])
  @@index([propertyId])
  @@index([userId])
}

model AiEvent {
  id         String      @id @default(uuid())
  type       AiEventType
  userId     String?
  propertyId String?
  payload    Json?
  createdAt  DateTime    @default(now())

  user     User?     @relation(fields: [userId], references: [id], onDelete: SetNull)
  property Property? @relation(fields: [propertyId], references: [id], onDelete: SetNull)
}

// =========================
// Audit (admin-ready)
// =========================

model AuditLog {
  id         String   @id @default(uuid())
  actorId    String?
  actor      User?    @relation("AuditActor", fields: [actorId], references: [id], onDelete: SetNull)
  action     String
  entityType String
  entityId   String
  before     Json?
  after      Json?
  ip         String?
  createdAt  DateTime @default(now())

  @@index([entityType, entityId])
  @@index([createdAt])
}
